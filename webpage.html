<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Satellite Multi-Data Viewer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
            color: white;
            overflow: hidden;
        }

        /* Top Navigation */
        .top-nav {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1001;
            gap: 20px;
        }

        .logo {
            font-size: 20px;
            font-weight: bold;
            color: rgba(18, 118, 158, 0.8);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .nav-buttons {
            display: flex;
            gap: 10px;
            margin-left: auto;
        }

        .nav-button {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
            position: relative;
        }

        .nav-button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-1px);
        }

        .nav-button.active {
            background: #12769ecc;
            box-shadow: 0 2px 8px rgba(33, 149, 243, 0.122);
        }

        .nav-button.dashboard {
            background: linear-gradient(45deg, #0a836b, #12769ecc);
        }

        .nav-button.dashboard:hover {
            background: linear-gradient(45deg, #0a836b, #12769ecc);
        }

        /* Sidebar */
        .sidebar {
            position: fixed;
            top: 60px;
            left: -380px;
            width: 320px;
            height: calc(100vh - 60px);
            background: rgba(0, 0, 0, 0.9);
            backdrop-filter: blur(15px);
            padding: 20px;
            overflow-y: auto;
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            transition: left 0.3s ease;
            z-index: 1000;
            box-shadow: 2px 0 10px rgba(0, 0, 0, 0.3); /* Add shadow for depth */
        }

        .sidebar::-webkit-scrollbar {
            width: 6px;                       /* Chrome, Safari, Edge */
        }

        .sidebar::-webkit-scrollbar-thumb {
            background-color: rgba(255,255,255,0.3);
            border-radius: 3px;
        }

        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }

        .sidebar.open {
            left: 0;
        }

        .sidebar-toggle {
            position: fixed;
            top: 360px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            border: none;
            color: rgb(0, 0, 0);
            padding: 12px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s;
            z-index: 1001;
            width: 45px;
            height: 45px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sidebar-toggle:hover {
            background: rgba(18, 118, 158, 0.8);
            transform: scale(1.1);
        }

        .sidebar-toggle.open {
            left: 345px;
        }

        /* Main content area */
        .main-content {
            margin-top: 60px;
            height: calc(100vh - 60px);
            position: relative;
            transition: margin-left 0.3s ease;
        }

        .main-content.sidebar-open {
            margin-left: 320px;
        }

        /* View controls */
        .view-controls {
            position: absolute;
            top: 565px;
            right: 20px;
            z-index: 1000;
            display: flex;
            gap: 10px;
        }

        .view-toggle, .refresh-btn {
            background: rgba(255, 255, 255, 0.8);
            border: none;
            color: rgb(17, 94, 135);
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s;
        }

        .view-toggle:hover, .refresh-btn:hover {
            background: rgba(18, 118, 158, 0.8);
            transform: translateY(-2px);
            color: #ffffffcc;
        }

        .refresh-btn {
            padding: 12px;
            border-radius: 50%;
        }

        /* Page containers */
        .page {
            width: 100%;
            height: 100%;
            display: none;
            position: relative;
        }

        .page.active {
            display: block;
        }

        /* Ensure map containers have proper dimensions */
        #conjunctions-mapView, #elset-mapView, #sgi-mapView, #statevector-mapView {
            width: 100%;
            height: 100%;
        }

        #conjunctions-globeView, #elset-globeView, #sgi-globeView, #statevector-globeView {
            width: 100%;
            height: 100%;
        }

        .hidden {
            display: none !important;
        }

        /* Sidebar content */
        .stats {
            background: rgba(255, 255, 255, 0.1);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }

        .data-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 6px;
            border-left: 4px solid;
            cursor: pointer;
            transition: all 0.3s;
        }

        .data-item:hover {
            background: rgba(255, 255, 255, 0.1);
            transform: translateX(5px);
        }

        .data-item.selected {
            background: rgba(33, 150, 243, 0.3);
        }

        .high-risk { border-left-color: #ff4757; }
        .medium-risk { border-left-color: #ffa726; }
        .low-risk { border-left-color: #66bb6a; }
        .active-satellite { border-left-color: #2196f3; }
        .inactive-satellite { border-left-color: #757575; }

        .data-header {
            font-weight: bold;
            margin-bottom: 5px;
        }

        .data-details {
            font-size: 12px;
            opacity: 0.8;
        }

        .filter-section {
            margin-bottom: 20px;
        }

        .filter-section h3 {
            margin-bottom: 10px;
            color: #178cbacc;
        }

        .filter-input {
            width: 100%;
            padding: 8px;
            border: none;
            border-radius: 4px;
            background: rgba(18, 118, 158, 0.1);
            color: white;
            margin-bottom: 10px;
        }

        .filter-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .filter-buttons {
            display: flex;
            gap: 5px;
            flex-wrap: wrap;
        }

        .filter-button {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: background 0.3s;
        }

        .filter-button.active {
            background: #086855;
        }

        .filter-button:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
        }

        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.1);
            border-top: 3px solid #12769ecc;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .error {
            color: #ff4757;
            text-align: center;
            padding: 20px;
            background: rgba(255, 71, 87, 0.1);
            border-radius: 8px;
            margin: 20px 0;
        }

        .tooltip {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            font-size: 12.5px;
            max-width: 180px;
        }

        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #12769ecc;
            font-size: 24px;
        }

        h2 {
            color: #086855;
            font-size: 18px;
            margin-bottom: 15px;
        }

        /* Leaflet control positioning */
        .leaflet-control-container {
            z-index: 990;
        }

        .leaflet-top {
            top: 20px;
        }
    </style>
</head>
<body>
    <!-- Top Navigation -->
    <nav class="top-nav">
        <div class="logo">
            <span>🛰️</span>
            Satellite Traffic Analytics!
        </div>
        <div class="nav-buttons">
            <button class="nav-button active" onclick="switchPage('conjunctions')">Conjunctions</button>
            <button class="nav-button" onclick="switchPage('elset')">ELSET Data</button>
            <button class="nav-button" onclick="switchPage('sgi')">SGI Data</button>
            <button class="nav-button" onclick="switchPage('statevector')">StateVector Data</button>
            <button class="nav-button dashboard" onclick="openDashboard()">📊 Analytics Dashboard</button>
        </div>
    </nav>

    <!-- Sidebar Toggle Button -->
    <button class="sidebar-toggle" onclick="toggleSidebar()">
        <span id="sidebarToggleIcon">☰</span>
    </button>

    <!-- Sidebar -->
    <div class="sidebar" id="sidebar">
        <h1 id="sidebarTitle">Conjunctions</h1>
        
        <div class="stats" id="stats">
            <h2>Statistics</h2>
            <div class="stat-item">
                <span>Total Items:</span>
                <span id="totalCount">0</span>
            </div>
            <div id="statsContent">
                <!-- Dynamic stats content -->
            </div>
        </div>

        <div class="filter-section">
            <h3>🔍 Filters</h3>
            <input type="text" class="filter-input" id="searchInput" placeholder="Search...">
            
            <div class="filter-buttons" id="filterButtons">
                <!-- Dynamic filter buttons -->
            </div>
        </div>

        <div id="dataList"></div>
    </div>
    
    <!-- Main Content -->
    <div class="main-content" id="mainContent">
        <!-- View Controls -->
        <div class="view-controls">
            <button class="refresh-btn" onclick="refreshData()" title="Refresh Data">🔄</button>
            <button class="view-toggle" onclick="toggleView()">
                <span id="viewToggleText">Switch to 3D Globe</span>
            </button>
        </div>

        <!-- Conjunctions Page -->
        <div class="page active" id="conjunctions-page">
            <div id="conjunctions-mapView"></div>
            <div id="conjunctions-globeView" class="hidden"></div>
        </div>

        <!-- ELSET Page -->
        <div class="page" id="elset-page">
            <div id="elset-mapView"></div>
            <div id="elset-globeView" class="hidden"></div>
        </div>

        <!-- SGI Page -->
        <div class="page" id="sgi-page">
            <div id="sgi-mapView"></div>
            <div id="sgi-globeView" class="hidden"></div>
        </div>

        <!-- StateVector Page -->
        <div class="page" id="statevector-page">
            <div id="statevector-mapView"></div>
            <div id="statevector-globeView" class="hidden"></div>
        </div>

        <!-- Loading indicator -->
        <div class="loading hidden" id="loading">
            <div class="spinner"></div>
            <div id="loadingText">Loading data...</div>
        </div>
    </div>

    <script>
        // Global application state
        let currentPage = 'conjunctions';
        let currentView = 'map';
        let sidebarOpen = false;

        // Data storage for each page type
        const dataStore = {};
        const filteredDataStore = {};
        const markersStore = {};
        const mapsStore = {};
        const globesStore = {};
        const currentViews = {};

        // Data configurations for different page types
        const dataConfigs = {
            conjunctions: {
                title: '🔗 Conjunctions',
                searchFields: ['name', 'satellite1_id', 'satellite2_id'],
                filters: [
                    { key: 'all', label: 'All', active: true },
                    { key: 'high', label: 'High Risk' },
                    { key: 'medium', label: 'Medium Risk' },
                    { key: 'low', label: 'Low Risk' }
                ],
                getMarkerStyle: (item) => {
                    const prob = item.properties.collision_probability || 0;
                    if (prob > 0.001) return { color: '#ff4757', radius: 8, class: 'high-risk' };
                    if (prob > 0.0001) return { color: '#ffa726', radius: 6, class: 'medium-risk' };
                    return { color: '#66bb6a', radius: 4, class: 'low-risk' };
                },
                getStats: (data) => {
                    let high = 0, medium = 0, low = 0;
                    data.forEach(item => {
                        const prob = item.properties.collision_probability || 0;
                        if (prob > 0.001) high++;
                        else if (prob > 0.0001) medium++;
                        else low++;
                    });
                    return [
                        { label: 'High Risk (>0.001)', value: high },
                        { label: 'Medium Risk (>0.0001)', value: medium },
                        { label: 'Low Risk', value: low }
                    ];
                },
                filterFunction: (item, filterKey, searchTerm) => {
                    const props = item.properties;
                    const prob = props.collision_probability || 0;
                    
                    // Text search
                    const searchMatch = !searchTerm || 
                        props.name?.toLowerCase().includes(searchTerm) ||
                        props.satellite1_id?.toLowerCase().includes(searchTerm) ||
                        props.satellite2_id?.toLowerCase().includes(searchTerm);
                    
                    // Risk filter
                    let filterMatch = true;
                    if (filterKey === 'high') filterMatch = prob > 0.001;
                    else if (filterKey === 'medium') filterMatch = prob > 0.0001 && prob <= 0.001;
                    else if (filterKey === 'low') filterMatch = prob <= 0.0001;
                    
                    return searchMatch && filterMatch;
                },
                renderListItem: (item) => {
                    const prob = item.properties.collision_probability || 0;
                    const style = dataConfigs.conjunctions.getMarkerStyle(item);
                    return `
                        <div class="data-header">
                            ${item.properties.satellite1_id} ↔ ${item.properties.satellite2_id}
                        </div>
                        <div class="data-details">
                            Risk: ${(prob * 1000000).toFixed(1)}/million<br>
                            Alt: ${item.properties.altitude_km || 'N/A'}km<br>
                            TCA: ${item.properties.tca ? new Date(item.properties.tca).toLocaleDateString() : 'N/A'}
                        </div>
                    `;
                },
                getPopupContent: (item) => {
                    const prob = item.properties.collision_probability || 0;
                    return `
                        <div class="tooltip">
                            <strong>${item.properties.name || 'Conjunction'}</strong><br>
                            <strong>Risk:</strong> ${(prob * 1000000).toFixed(3)}/million<br>
                            <strong>Altitude:</strong> ${item.properties.altitude_km || 'N/A'}km<br>
                            <strong>TCA:</strong> ${item.properties.tca ? new Date(item.properties.tca).toLocaleString() : 'N/A'}<br>
                            <strong>Satellites:</strong> ${item.properties.satellite1_id} & ${item.properties.satellite2_id}
                        </div>
                    `;
                }
            },
            elset: {
                title: '📡 ELSET Data',
                searchFields: ['name', 'satellite_id', 'object_name'],
                filters: [
                    { key: 'all', label: 'All', active: true },
                    { key: 'active', label: 'Active' },
                    { key: 'inactive', label: 'Inactive' }
                ],
                getMarkerStyle: (item) => {
                    const status = item.properties.status || 'unknown';
                    if (status.toLowerCase() === 'active') return { color: '#2196f3', radius: 8, class: 'active-satellite' };
                    return { color: '#757575', radius: 6, class: 'inactive-satellite' };
                },
                getStats: (data) => {
                    let active = 0, inactive = 0;
                    data.forEach(item => {
                        const status = item.properties.status?.toLowerCase() || 'unknown';
                        if (status === 'active') active++;
                        else inactive++;
                    });
                    return [
                        { label: 'Active Satellites', value: active },
                        { label: 'Inactive Satellites', value: inactive }
                    ];
                },
                filterFunction: (item, filterKey, searchTerm) => {
                    const props = item.properties;
                    const status = props.status?.toLowerCase() || 'unknown';
                    
                    const searchMatch = !searchTerm || 
                        props.name?.toLowerCase().includes(searchTerm) ||
                        props.satellite_id?.toLowerCase().includes(searchTerm) ||
                        props.object_name?.toLowerCase().includes(searchTerm);
                    
                    let filterMatch = true;
                    if (filterKey === 'active') filterMatch = status === 'active';
                    else if (filterKey === 'inactive') filterMatch = status !== 'active';
                    
                    return searchMatch && filterMatch;
                },
                renderListItem: (item) => {
                    const style = dataConfigs.elset.getMarkerStyle(item);
                    return `
                        <div class="data-header">
                            ${item.properties.object_name || item.properties.name || 'Satellite'}
                        </div>
                        <div class="data-details">
                            ID: ${item.properties.satellite_id || 'N/A'}<br>
                            Status: ${item.properties.status || 'Unknown'}<br>
                            Epoch: ${item.properties.epoch ? new Date(item.properties.epoch).toLocaleDateString() : 'N/A'}
                        </div>
                    `;
                },
                getPopupContent: (item) => {
                    return `
                        <div class="tooltip">
                            <strong>${item.properties.object_name || item.properties.name || 'Satellite'}</strong><br>
                            <strong>ID:</strong> ${item.properties.satellite_id || 'N/A'}<br>
                            <strong>Status:</strong> ${item.properties.status || 'Unknown'}<br>
                            <strong>Epoch:</strong> ${item.properties.epoch ? new Date(item.properties.epoch).toLocaleString() : 'N/A'}<br>
                            <strong>Mean Motion:</strong> ${item.properties.mean_motion || 'N/A'}/day
                        </div>
                    `;
                }
            },
            sgi: {
                title: '🌍 SGI Data',
                searchFields: ['name', 'object_id', 'country', 'owner'],
                filters: [
                    { key: 'all', label: 'All', active: true },
                    { key: 'us', label: 'US' },
                    { key: 'russia', label: 'Russia' },
                    { key: 'china', label: 'China' },
                    { key: 'other', label: 'Other' }
                ],
                getMarkerStyle: (item) => {
                    const country = item.properties.country?.toLowerCase() || '';
                    if (country.includes('us') || country.includes('united states')) return { color: '#2196f3', radius: 7, class: 'us-satellite' };
                    if (country.includes('russia') || country.includes('cis')) return { color: '#f44336', radius: 7, class: 'russia-satellite' };
                    if (country.includes('china')) return { color: '#ff9800', radius: 7, class: 'china-satellite' };
                    return { color: '#4caf50', radius: 6, class: 'other-satellite' };
                },
                getStats: (data) => {
                    let us = 0, russia = 0, china = 0, other = 0;
                    data.forEach(item => {
                        const country = item.properties.country?.toLowerCase() || '';
                        if (country.includes('us') || country.includes('united states')) us++;
                        else if (country.includes('russia') || country.includes('cis')) russia++;
                        else if (country.includes('china')) china++;
                        else other++;
                    });
                    return [
                        { label: 'US', value: us },
                        { label: 'Russia', value: russia },
                        { label: 'China', value: china },
                        { label: 'Other', value: other }
                    ];
                },
                filterFunction: (item, filterKey, searchTerm) => {
                    const props = item.properties;
                    const country = props.country?.toLowerCase() || '';
                    
                    const searchMatch = !searchTerm || 
                        props.name?.toLowerCase().includes(searchTerm) ||
                        props.object_id?.toLowerCase().includes(searchTerm) ||
                        props.country?.toLowerCase().includes(searchTerm) ||
                        props.owner?.toLowerCase().includes(searchTerm);
                    
                    let filterMatch = true;
                    if (filterKey === 'us') filterMatch = country.includes('us') || country.includes('united states');
                    else if (filterKey === 'russia') filterMatch = country.includes('russia') || country.includes('cis');
                    else if (filterKey === 'china') filterMatch = country.includes('china');
                    else if (filterKey === 'other') filterMatch = !country.includes('us') && !country.includes('united states') && 
                                                                   !country.includes('russia') && !country.includes('cis') && 
                                                                   !country.includes('china');
                    
                    return searchMatch && filterMatch;
                },
                renderListItem: (item) => {
                    return `
                        <div class="data-header">
                            ${item.properties.name || 'Satellite'}
                        </div>
                        <div class="data-details">
                            ID: ${item.properties.object_id || 'N/A'}<br>
                            Country: ${item.properties.country || 'Unknown'}<br>
                            Owner: ${item.properties.owner || 'Unknown'}
                        </div>
                    `;
                },
                getPopupContent: (item) => {
                    return `
                        <div class="tooltip">
                            <strong>${item.properties.name || 'Satellite'}</strong><br>
                            <strong>ID:</strong> ${item.properties.object_id || 'N/A'}<br>
                            <strong>Country:</strong> ${item.properties.country || 'Unknown'}<br>
                            <strong>Owner:</strong> ${item.properties.owner || 'Unknown'}<br>
                            <strong>Launch Date:</strong> ${item.properties.launch_date ? new Date(item.properties.launch_date).toLocaleDateString() : 'N/A'}
                        </div>
                    `;
                }
            },
            statevector: {
                title: '📊 StateVector Data',
                searchFields: ['name', 'satellite_id', 'epoch'],
                filters: [
                    { key: 'all', label: 'All', active: true },
                    { key: 'recent', label: 'Recent (24h)' },
                    { key: 'leo', label: 'LEO' },
                    { key: 'geo', label: 'GEO' }
                ],
                getMarkerStyle: (item) => {
                    const altitude = item.properties.altitude_km || item.geometry.coordinates[2] / 1000 || 0;
                    if (altitude > 35000) return { color: '#9c27b0', radius: 8, class: 'geo-satellite' };
                    if (altitude < 2000) return { color: '#00bcd4', radius: 6, class: 'leo-satellite' };
                    return { color: '#ff5722', radius: 7, class: 'meo-satellite' };
                },
                getStats: (data) => {
                    let leo = 0, meo = 0, geo = 0;
                    data.forEach(item => {
                        const altitude = item.properties.altitude_km || item.geometry.coordinates[2] / 1000 || 0;
                        if (altitude > 35000) geo++;
                        else if (altitude < 2000) leo++;
                        else meo++;
                    });
                    return [
                        { label: 'LEO (<2000km)', value: leo },
                        { label: 'MEO (2000-35000km)', value: meo },
                        { label: 'GEO (>35000km)', value: geo }
                    ];
                },
                filterFunction: (item, filterKey, searchTerm) => {
                    const props = item.properties;
                    const altitude = props.altitude_km || item.geometry.coordinates[2] / 1000 || 0;
                    
                    const searchMatch = !searchTerm || 
                        props.name?.toLowerCase().includes(searchTerm) ||
                        props.satellite_id?.toLowerCase().includes(searchTerm) ||
                        props.epoch?.toLowerCase().includes(searchTerm);
                    
                    let filterMatch = true;
                    if (filterKey === 'recent') {
                        const epochDate = new Date(props.epoch);
                        const now = new Date();
                        const dayAgo = new Date(now.getTime() - 24 * 60 * 60 * 1000);
                        filterMatch = epochDate > dayAgo;
                    } else if (filterKey === 'leo') filterMatch = altitude < 2000;
                    else if (filterKey === 'geo') filterMatch = altitude > 35000;
                    
                    return searchMatch && filterMatch;
                },
                renderListItem: (item) => {
                    const altitude = item.properties.altitude_km || item.geometry.coordinates[2] / 1000 || 0;
                    return `
                        <div class="data-header">
                            ${item.properties.name || item.properties.satellite_id || 'Satellite'}
                        </div>
                        <div class="data-details">
                            ID: ${item.properties.satellite_id || 'N/A'}<br>
                            Alt: ${altitude.toFixed(1)}km<br>
                            Epoch: ${item.properties.epoch ? new Date(item.properties.epoch).toLocaleDateString() : 'N/A'}
                        </div>
                    `;
                },
                getPopupContent: (item) => {
                    const altitude = item.properties.altitude_km || item.geometry.coordinates[2] / 1000 || 0;
                    return `
                        <div class="tooltip">
                            <strong>${item.properties.name || item.properties.satellite_id || 'Satellite'}</strong><br>
                            <strong>ID:</strong> ${item.properties.satellite_id || 'N/A'}<br>
                            <strong>Altitude:</strong> ${altitude.toFixed(1)}km<br>
                            <strong>Epoch:</strong> ${item.properties.epoch ? new Date(item.properties.epoch).toLocaleString() : 'N/A'}<br>
                            <strong>Velocity:</strong> ${item.properties.velocity_kms || 'N/A'} km/s
                        </div>
                    `;
                }
            }
        };

        // Sample data generators for demonstration
        function generateSampleData(type, count = 250) {
            const data = [];
            
            for (let i = 0; i < count; i++) {
                const lat = (Math.random() - 0.5) * 180;
                const lng = (Math.random() - 0.5) * 360;
                const alt = Math.random() * 40000;
                
                let item = {
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [lng, lat, alt * 1000] // altitude in meters
                    },
                    properties: {}
                };
                
                switch (type) {
                    case 'conjunctions':
                        item.properties = {
                            name: `Conjunction ${1000 + i}-${2000 + i}`,
                            tca: new Date(Date.now() + Math.random() * 30 * 24 * 60 * 60 * 1000).toISOString(),
                            collision_probability: Math.random() * 0.01,
                            satellite1_id: `${1000 + i}`,
                            satellite2_id: `${2000 + i}`,
                            altitude_km: Math.floor(alt)
                        };
                        break;
                        
                    case 'elset':
                        item.properties = {
                            name: `Satellite ${1000 + i}`,
                            satellite_id: `${1000 + i}`,
                            object_name: `SATELLITE-${i}`,
                            status: Math.random() > 0.3 ? 'active' : 'inactive',
                            epoch: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
                            mean_motion: (Math.random() * 16).toFixed(2)
                        };
                        break;
                        
                    case 'sgi':
                        const countries = ['United States', 'Russia', 'China', 'France', 'Japan', 'India', 'Germany'];
                        const country = countries[Math.floor(Math.random() * countries.length)];
                        item.properties = {
                            name: `SGI-SAT-${1000 + i}`,
                            object_id: `${10000 + i}`,
                            country: country,
                            owner: country === 'United States' ? 'NASA/USAF' : country,
                            launch_date: new Date(Date.now() - Math.random() * 10 * 365 * 24 * 60 * 60 * 1000).toISOString()
                        };
                        break;
                        
                    case 'statevector':
                        item.properties = {
                            name: `StateVector-${1000 + i}`,
                            satellite_id: `${1000 + i}`,
                            epoch: new Date(Date.now() - Math.random() * 7 * 24 * 60 * 60 * 1000).toISOString(),
                            altitude_km: Math.floor(alt),
                            velocity_kms: (Math.random() * 15 + 5).toFixed(2)
                        };
                        break;
                }
                
                data.push(item);
            }
            
            return data;
        }

        // Initialize application
        function initApp() {
            // Initialize maps for all page types
            Object.keys(dataConfigs).forEach(pageType => {
                currentViews[pageType] = 'map';
                dataStore[pageType] = [];
                filteredDataStore[pageType] = [];
                markersStore[pageType] = [];
                initMap(pageType);
                loadData(pageType);
            });

            setupEventListeners();
        }

        // Initialize map for a specific page type
        function initMap(pageType) {
            const mapContainer = document.getElementById(`${pageType}-mapView`);
            if (!mapContainer) {
                console.error(`Map container not found: ${pageType}-mapView`);
                return;
            }

            // Ensure container has dimensions
            mapContainer.style.width = '100%';
            mapContainer.style.height = '100%';

            const map = L.map(mapContainer, {
                center: [0, 0],
                zoom: 2,
                preferCanvas: true
            });

            // Add different base layers
            const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri'
            });

            const dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; OpenStreetMap contributors &copy; CARTO'
            });

            satellite.addTo(map);

            // Add layer control
            L.control.layers({
                'Satellite': satellite,
                'Dark': dark
            }).addTo(map);

            mapsStore[pageType] = map;
            
            // Force map to recognize its container size
            setTimeout(() => {
                map.invalidateSize();
            }, 100);
        }

        // Initialize 3D globe for a specific page type
        function initGlobe(pageType) {
            const container = document.getElementById(`${pageType}-globeView`);
            if (!container || globesStore[pageType]) return;

            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.setClearColor(0x000011);
            container.appendChild(renderer.domElement);

            // Create Earth sphere
            const earthGeometry = new THREE.SphereGeometry(5, 64, 64);
            
            // Create a basic blue material as fallback
            const earthMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x6B93D6,
                shininess: 0.5
            });
            
            // Try to load Earth texture
            const textureLoader = new THREE.TextureLoader();
            textureLoader.load(
                'https://unpkg.com/three-globe/example/img/earth-blue-marble.jpg',
                (texture) => {
                    earthMaterial.map = texture;
                    earthMaterial.needsUpdate = true;
                },
                undefined,
                (error) => {
                    console.log('Failed to load Earth texture, using solid color');
                }
            );
            
            const earth = new THREE.Mesh(earthGeometry, earthMaterial);
            scene.add(earth);

            // Add atmosphere effect
            const atmosphereGeometry = new THREE.SphereGeometry(5.1, 64, 64);
            const atmosphereMaterial = new THREE.MeshPhongMaterial({
                color: 0x87CEEB,
                transparent: true,
                opacity: 0.15
            });
            const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial);
            scene.add(atmosphere);

            // Add lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(10, 5, 5);
            scene.add(directionalLight);

            // Position camera
            camera.position.z = 15;

            // Mouse interaction variables
            let isMouseDown = false;
            let mouseX = 0, mouseY = 0;
            let previousMousePosition = { x: 0, y: 0 };

            // Mouse event listeners
            container.addEventListener('mousedown', (event) => {
                isMouseDown = true;
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            });

            container.addEventListener('mouseup', () => {
                isMouseDown = false;
            });

            container.addEventListener('mousemove', (event) => {
                if (isMouseDown) {
                    const deltaMove = {
                        x: event.clientX - previousMousePosition.x,
                        y: event.clientY - previousMousePosition.y
                    };

                    const deltaRotationQuaternion = new THREE.Quaternion()
                        .setFromEuler(new THREE.Euler(
                            deltaMove.y * 0.01,
                            deltaMove.x * 0.01,
                            0,
                            'XYZ'
                        ));

                    earth.quaternion.multiplyQuaternions(deltaRotationQuaternion, earth.quaternion);
                    atmosphere.quaternion.copy(earth.quaternion);

                    previousMousePosition.x = event.clientX;
                    previousMousePosition.y = event.clientY;
                }
            });

            // Zoom with mouse wheel
            container.addEventListener('wheel', (event) => {
                event.preventDefault();
                camera.position.z += event.deltaY * 0.01;
                camera.position.z = Math.max(8, Math.min(50, camera.position.z));
            });

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                
                // Gentle auto-rotation
                if (!isMouseDown) {
                    earth.rotation.y += 0.002;
                    atmosphere.rotation.y += 0.002;
                }
                
                renderer.render(scene, camera);
            }
            animate();

            // Store globe references
            globesStore[pageType] = { 
                scene, 
                camera, 
                renderer, 
                earth, 
                atmosphere,
                container,
                markers: [] // Store markers for this globe
            };
        }

        // Load data for a specific page type
        function loadData(pageType) {
            showLoading(`Loading ${dataConfigs[pageType].title}...`);
            
            // Try to fetch real data first
            const fileName = `${pageType}.geojson`;
            
            fetch(fileName)
                .then(response => {
                    if (!response.ok) throw new Error('File not found');
                    return response.json();
                })
                .then(data => {
                    if (data.features && Array.isArray(data.features)) {
                        dataStore[pageType] = data.features;
                    } else {
                        throw new Error('Invalid GeoJSON format');
                    }
                })
                .catch(() => {
                    // Use sample data if file doesn't exist or is invalid
                    console.log(`Using sample data for ${pageType}`);
                    dataStore[pageType] = generateSampleData(pageType);
                })
                .finally(() => {
                    hideLoading();
                    processData(pageType);
                });
        }

        // Process and display data for a specific page type
        function processData(pageType) {
            const data = dataStore[pageType];
            const config = dataConfigs[pageType];
            
            // Update statistics
            updateStats(pageType, data);
            
            // Setup filters
            setupFilters(pageType);
            
            // Apply initial filters
            applyFilters(pageType);
        }

        // Update statistics display
        function updateStats(pageType, data) {
            document.getElementById('totalCount').textContent = data.length;
            
            const config = dataConfigs[pageType];
            const stats = config.getStats(data);
            
            const statsContent = document.getElementById('statsContent');
            statsContent.innerHTML = stats.map(stat => `
                <div class="stat-item">
                    <span>${stat.label}:</span>
                    <span>${stat.value}</span>
                </div>
            `).join('');
        }

        // Setup filter buttons for a page type
        function setupFilters(pageType) {
            const config = dataConfigs[pageType];
            const filterButtons = document.getElementById('filterButtons');
            
            filterButtons.innerHTML = config.filters.map(filter => `
                <button class="filter-button ${filter.active ? 'active' : ''}" 
                        data-filter="${filter.key}" 
                        onclick="setFilter('${pageType}', '${filter.key}')">
                    ${filter.label}
                </button>
            `).join('');
        }

        // Set active filter
        function setFilter(pageType, filterKey) {
            document.querySelectorAll('.filter-button').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.filter === filterKey);
            });
            applyFilters(pageType);
        }

        // Apply filters to data
        function applyFilters(pageType) {
            const data = dataStore[pageType];
            const config = dataConfigs[pageType];
            const searchTerm = document.getElementById('searchInput').value.toLowerCase();
            const activeFilter = document.querySelector('.filter-button.active').dataset.filter;

            filteredDataStore[pageType] = data.filter(item => 
                config.filterFunction(item, activeFilter, searchTerm)
            );

            updateDataList(pageType);
            updateMapMarkers(pageType);
            
            if (currentViews[pageType] === 'globe') {
                updateGlobeMarkers(pageType);
            }
        }

        // Update data list in sidebar
        function updateDataList(pageType) {
            const data = filteredDataStore[pageType];
            const config = dataConfigs[pageType];
            const list = document.getElementById('dataList');
            
            list.innerHTML = data.map((item, index) => {
                const style = config.getMarkerStyle(item);
                return `
                    <div class="data-item ${style.class}" 
                         onclick="selectDataItem('${pageType}', ${index})">
                        ${config.renderListItem(item)}
                    </div>
                `;
            }).join('');
        }

        // Select a specific data item
        function selectDataItem(pageType, index) {
            const item = filteredDataStore[pageType][index];
            
            // Highlight in list
            document.querySelectorAll('.data-item').forEach((elem, i) => {
                elem.classList.toggle('selected', i === index);
            });

            // Center map/globe on item
            const coords = item.geometry.coordinates;
            
            if (currentViews[pageType] === 'map' && mapsStore[pageType]) {
                mapsStore[pageType].setView([coords[1], coords[0]], 6);
            } else if (currentViews[pageType] === 'globe' && globesStore[pageType]) {
                // For globe, we could implement smooth camera movement here
                focusGlobeOnPoint(pageType, coords[1], coords[0]);
            }
        }

        // Focus globe camera on a specific point
        function focusGlobeOnPoint(pageType, lat, lng) {
            const globe = globesStore[pageType];
            if (!globe) return;

            // Convert lat/lng to 3D position
            const phi = (90 - lat) * Math.PI / 180;
            const theta = (lng + 180) * Math.PI / 180;

            const targetPosition = new THREE.Vector3();
            targetPosition.x = 15 * Math.sin(phi) * Math.cos(theta);
            targetPosition.y = 15 * Math.cos(phi);
            targetPosition.z = 15 * Math.sin(phi) * Math.sin(theta);

            // Smooth camera movement (basic implementation)
            const startPosition = globe.camera.position.clone();
            const steps = 60;
            let step = 0;

            function animate() {
                if (step < steps) {
                    const progress = step / steps;
                    const easeProgress = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                    
                    globe.camera.position.lerpVectors(startPosition, targetPosition, easeProgress);
                    globe.camera.lookAt(0, 0, 0);
                    
                    step++;
                    requestAnimationFrame(animate);
                }
            }
            animate();
        }

        // Update map markers for a specific page type
        function updateMapMarkers(pageType) {
            const map = mapsStore[pageType];
            const data = filteredDataStore[pageType];
            const config = dataConfigs[pageType];
            
            if (!map) return;

            // Clear existing markers
            if (markersStore[pageType]) {
                markersStore[pageType].forEach(marker => map.removeLayer(marker));
            }
            markersStore[pageType] = [];

            // Add new markers
            data.forEach(item => {
                const coords = item.geometry.coordinates;
                const lat = coords[1];
                const lng = coords[0];
                const style = config.getMarkerStyle(item);

                const marker = L.circleMarker([lat, lng], {
                    radius: style.radius,
                    fillColor: style.color,
                    color: 'white',
                    weight: 2,
                    opacity: 0.8,
                    fillOpacity: 0.6
                });

                marker.bindPopup(config.getPopupContent(item));
                marker.addTo(map);
                markersStore[pageType].push(marker);
            });
        }

        // Update globe markers for a specific page type
        function updateGlobeMarkers(pageType) {
            const globe = globesStore[pageType];
            const data = filteredDataStore[pageType];
            const config = dataConfigs[pageType];
            
            if (!globe) return;

            // Clear existing markers
            globe.markers.forEach(marker => globe.earth.remove(marker)); // remove from earth
            globe.markers = [];

            // Add new markers
            data.forEach(item => {
                const coords = item.geometry.coordinates;
                const lat = coords[1]; // latitude in degrees
                const lng = coords[0]; // longitude in degrees
                const style = config.getMarkerStyle(item);

                // Convert lat/lng to 3D coordinates on sphere surface
                const phi = (90 - lat) * Math.PI / 180; // polar angle
                const theta = (lng + 180) * Math.PI / 180; // azimuthal angle
                
                const radius = 5.1; // slightly above Earth surface
                const x = radius * Math.sin(phi) * Math.cos(theta);
                const y = radius * Math.cos(phi);
                const z = radius * Math.sin(phi) * Math.sin(theta);

                // Create marker
                const markerSize = 0.05 + (style.radius * 0.005);
                const markerGeometry = new THREE.SphereGeometry(markerSize, 16, 16);
                const markerMaterial = new THREE.MeshPhongMaterial({ 
                    color: new THREE.Color(style.color),
                    emissive: new THREE.Color(style.color).multiplyScalar(0.2)
                });
                const marker = new THREE.Mesh(markerGeometry, markerMaterial);
                marker.position.set(x, y, z);

                // Attach marker to the earth mesh so it rotates with it
                globe.earth.add(marker);

                // Store reference
                marker.userData = item;
                globe.markers.push(marker);
            });

            console.log(`Added ${globe.markers.length} markers to ${pageType} globe`);
        }

        // Page switching functionality
        function switchPage(pageType) {
            // Update nav buttons
            document.querySelectorAll('.nav-button').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            // Hide all pages
            document.querySelectorAll('.page').forEach(page => {
                page.classList.remove('active');
            });

            // Show selected page
            document.getElementById(`${pageType}-page`).classList.add('active');

            // Update sidebar title
            document.getElementById('sidebarTitle').textContent = dataConfigs[pageType].title;

            // Update search placeholder
            const searchFields = dataConfigs[pageType].searchFields.join(', ');
            document.getElementById('searchInput').placeholder = `Search ${searchFields}...`;

            // Update current page
            currentPage = pageType;
            currentView = currentViews[pageType];

            // Update view toggle text
            const viewToggleText = document.getElementById('viewToggleText');
            viewToggleText.textContent = currentView === 'map' ? 'Switch to 3D Globe' : 'Switch to 2D Map';

            // Refresh map size
            setTimeout(() => {
                if (mapsStore[pageType]) {
                    mapsStore[pageType].invalidateSize();
                }
            }, 100);

            // Update sidebar with current page data
            processData(pageType);
        }

        // Toggle between map and globe views
        function toggleView() {
            const currentPageType = currentPage;
            const mapView = document.getElementById(`${currentPageType}-mapView`);
            const globeView = document.getElementById(`${currentPageType}-globeView`);
            const toggleText = document.getElementById('viewToggleText');

            if (currentViews[currentPageType] === 'map') {
                mapView.classList.add('hidden');
                globeView.classList.remove('hidden');
                toggleText.textContent = 'Switch to 2D Map';
                currentViews[currentPageType] = 'globe';
                currentView = 'globe';
                
                if (!globesStore[currentPageType]) {
                    initGlobe(currentPageType);
                }
                updateGlobeMarkers(currentPageType);
            } else {
                globeView.classList.add('hidden');
                mapView.classList.remove('hidden');
                toggleText.textContent = 'Switch to 3D Globe';
                currentViews[currentPageType] = 'map';
                currentView = 'map';
                
                updateMapMarkers(currentPageType);
            }
        }

        // Sidebar toggle functionality
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const mainContent = document.getElementById('mainContent');
            const toggleBtn = document.querySelector('.sidebar-toggle');
            const toggleIcon = document.getElementById('sidebarToggleIcon');

            sidebarOpen = !sidebarOpen;

            if (sidebarOpen) {
                sidebar.classList.add('open');
                mainContent.classList.add('sidebar-open');
                toggleBtn.classList.add('open');
                toggleIcon.textContent = '✕';
            } else {
                sidebar.classList.remove('open');
                mainContent.classList.remove('sidebar-open');
                toggleBtn.classList.remove('open');
                toggleIcon.textContent = '☰';
            }

            // Invalidate map size after sidebar animation
            setTimeout(() => {
                if (mapsStore[currentPage]) {
                    mapsStore[currentPage].invalidateSize();
                }
            }, 300);
        }

        // Refresh data for current page
        function refreshData() {
            loadData(currentPage);
        }

        // Open external dashboard
        function openDashboard() {
            window.open('https://lookerstudio.google.com/reporting/e48b3d5f-7f77-436c-9567-f7445bad4225', '_blank');
        }

        // Show loading indicator
        function showLoading(message = 'Loading...') {
            const loading = document.getElementById('loading');
            const loadingText = document.getElementById('loadingText');
            loadingText.textContent = message;
            loading.classList.remove('hidden');
        }

        // Hide loading indicator
        function hideLoading() {
            document.getElementById('loading').classList.add('hidden');
        }

        // Setup event listeners
        function setupEventListeners() {
            // Search input
            document.getElementById('searchInput').addEventListener('input', () => {
                applyFilters(currentPage);
            });

            // Handle window resize
            window.addEventListener('resize', () => {
                // Resize maps
                Object.values(mapsStore).forEach(map => {
                    if (map) map.invalidateSize();
                });

                // Resize globes
                Object.entries(globesStore).forEach(([pageType, globe]) => {
                    if (globe && currentViews[pageType] === 'globe') {
                        const container = globe.container;
                        globe.camera.aspect = container.clientWidth / container.clientHeight;
                        globe.camera.updateProjectionMatrix();
                        globe.renderer.setSize(container.clientWidth, container.clientHeight);
                    }
                });
            });
        }

        // Initialize the application when DOM is ready
        document.addEventListener('DOMContentLoaded', () => {
            initApp();
        });
    </script>
</body>
</html>